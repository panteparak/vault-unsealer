name: 'Run Unit Tests'
description: 'Run Go unit tests with coverage and race detection'

inputs:
  go-version:
    description: 'Go version to use'
    required: false
    default: '1.24'
  coverage:
    description: 'Enable coverage reporting'
    required: false
    default: 'true'
  race-detection:
    description: 'Enable race detection'
    required: false
    default: 'true'
  timeout:
    description: 'Test timeout'
    required: false
    default: '10m'
  parallel:
    description: 'Number of parallel test processes'
    required: false
    default: '4'
  test-tags:
    description: 'Additional build tags for tests'
    required: false
    default: ''
  upload-coverage:
    description: 'Upload coverage to Codecov'
    required: false
    default: 'false'

outputs:
  result:
    description: 'Test result (success/failure)'
    value: ${{ steps.test-result.outputs.result }}
  coverage:
    description: 'Coverage percentage'
    value: ${{ steps.coverage.outputs.percentage }}

runs:
  using: 'composite'
  steps:
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ inputs.go-version }}
        cache: true

    - name: Create test directories
      shell: bash
      run: |
        mkdir -p coverage reports artifacts
        echo "ðŸ“ Test directories created"

    - name: Determine test packages and tags
      id: config
      shell: bash
      run: |
        echo "ðŸ” Configuring unit tests..."

        PACKAGES="./test/unit/..."
        BASE_TAGS="unit"

        # Add custom tags if provided
        if [[ -n "${{ inputs.test-tags }}" ]]; then
          TAGS="$BASE_TAGS,${{ inputs.test-tags }}"
        else
          TAGS="$BASE_TAGS"
        fi

        echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
        echo "tags=$TAGS" >> $GITHUB_OUTPUT

        echo "âœ… Unit test configuration:"
        echo "  Packages: $PACKAGES"
        echo "  Tags: $TAGS"

    - name: Run unit tests
      id: run-tests
      shell: bash
      run: |
        echo "ðŸ§ª Running unit tests using make..."

        # Set environment variables for make command
        export TEST_TIMEOUT="${{ inputs.timeout }}"
        export PARALLELISM="${{ inputs.parallel }}"
        export VERBOSE="true"
        export CI="true"

        # Add race detection for CI
        if [[ "${{ inputs.race-detection }}" == "true" ]]; then
          export CI="true"  # This enables race detection in the Makefile
        fi

        # Run tests using make command for consistency
        if make test-unit 2>&1 | tee "reports/unit-test-output.log"; then
          echo "result=success" >> $GITHUB_OUTPUT
          echo "âœ… Unit tests completed successfully"
        else
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "âŒ Unit tests failed"
          exit 1
        fi

    - name: Generate test summary
      id: summary
      if: always()
      shell: bash
      run: |
        echo "ðŸ“Š Generating unit test summary..."

        # Parse test results
        TOTAL_TESTS=$(grep -c "^=== RUN" reports/unit-test-output.log 2>/dev/null || echo "0")
        PASSED_TESTS=$(grep -c "--- PASS:" reports/unit-test-output.log 2>/dev/null || echo "0")
        FAILED_TESTS=$(grep -c "--- FAIL:" reports/unit-test-output.log 2>/dev/null || echo "0")
        SKIPPED_TESTS=$(grep -c "--- SKIP:" reports/unit-test-output.log 2>/dev/null || echo "0")

        # Generate summary
        SUMMARY="## ðŸ§ª Unit Test Results\\n\\n"
        SUMMARY="${SUMMARY}| Metric | Count |\\n"
        SUMMARY="${SUMMARY}|--------|-------|\\n"
        SUMMARY="${SUMMARY}| Total | $TOTAL_TESTS |\\n"
        SUMMARY="${SUMMARY}| Passed | $PASSED_TESTS |\\n"
        SUMMARY="${SUMMARY}| Failed | $FAILED_TESTS |\\n"
        SUMMARY="${SUMMARY}| Skipped | $SKIPPED_TESTS |\\n"

        echo "report<<EOF" >> $GITHUB_OUTPUT
        echo -e "$SUMMARY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Add to step summary
        echo -e "$SUMMARY" >> $GITHUB_STEP_SUMMARY

    - name: Process coverage
      id: coverage
      if: inputs.coverage == 'true' && always()
      shell: bash
      run: |
        # Coverage data should already be in coverage.out from make test-unit
        if [[ -f "coverage.out" ]]; then
          echo "ðŸ“ˆ Processing coverage data..."
          cp coverage.out coverage/coverage.out

          # Extract coverage percentage with error handling for module resolution issues
          if COVERAGE=$(go tool cover -func=coverage/coverage.out 2>/dev/null | grep "total:" | awk '{print $3}' | sed 's/%//'); then
            echo "percentage=$COVERAGE" >> $GITHUB_OUTPUT
            echo "âœ… Coverage: $COVERAGE%"

            # Add coverage to summary
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“Š Coverage: $COVERAGE%" >> $GITHUB_STEP_SUMMARY
          else
            echo "âš ï¸ Coverage processing failed, likely due to module resolution issues"
            echo "â„¹ï¸ This is expected for isolated unit tests that use mocks"
            echo "percentage=0" >> $GITHUB_OUTPUT

            # Add note to summary
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "### ðŸ“Š Coverage: Not measurable (isolated unit tests)" >> $GITHUB_STEP_SUMMARY
          fi
        else
          echo "âš ï¸ No coverage data found"
          echo "percentage=0" >> $GITHUB_OUTPUT
        fi

    - name: Upload coverage to Codecov
      if: inputs.upload-coverage == 'true' && inputs.coverage == 'true'
      uses: codecov/codecov-action@v4
      with:
        file: coverage/coverage.out
        flags: unittests
        name: unit-test-coverage
        fail_ci_if_error: false

    - name: Upload test artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: unit-test-results-${{ github.run_number }}
        path: |
          coverage/
          reports/
          artifacts/
          *.log
        retention-days: 14

    - name: Set test result
      id: test-result
      if: always()
      shell: bash
      run: |
        if [[ "${{ steps.run-tests.outputs.result }}" == "success" ]]; then
          echo "result=success" >> $GITHUB_OUTPUT
        else
          echo "result=failure" >> $GITHUB_OUTPUT
        fi
