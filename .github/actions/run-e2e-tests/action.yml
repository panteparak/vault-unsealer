name: 'Run E2E Tests'
description: 'Run Go end-to-end tests with K8s infrastructure'

inputs:
  go-version:
    description: 'Go version to use'
    required: false
    default: '1.24'
  coverage:
    description: 'Enable coverage reporting'
    required: false
    default: 'false'
  timeout:
    description: 'Test timeout'
    required: false
    default: '20m'
  parallel:
    description: 'Number of parallel test processes'
    required: false
    default: '2'
  test-tags:
    description: 'Additional build tags for tests'
    required: false
    default: ''
  vault-version:
    description: 'Vault version for E2E tests'
    required: false
    default: ''
  k3s-version:
    description: 'K3s version for E2E tests'
    required: false
    default: ''

outputs:
  result:
    description: 'Test result (success/failure)'
    value: ${{ steps.test-result.outputs.result }}
  coverage:
    description: 'Coverage percentage'
    value: ${{ steps.coverage.outputs.percentage }}

runs:
  using: 'composite'
  steps:
    - name: Setup Go
      uses: actions/setup-go@v5
      with:
        go-version: ${{ inputs.go-version }}
        cache: true

    - name: Create test directories
      shell: bash
      run: |
        mkdir -p coverage reports artifacts
        echo "üìÅ Test directories created"

    - name: Setup E2E test dependencies
      shell: bash
      run: |
        echo "üîß Setting up E2E test dependencies..."

        # Load versions from config or use provided values
        if [[ -n "${{ inputs.vault-version }}" ]]; then
          VAULT_VERSION="${{ inputs.vault-version }}"
        else
          VAULT_VERSION="1.19.0"  # Default value since config was merged
        fi

        if [[ -n "${{ inputs.k3s-version }}" ]]; then
          K3S_VERSION="${{ inputs.k3s-version }}"
        else
          K3S_VERSION="v1.30.8-k3s1"  # Default value since config was merged
        fi

        echo "VAULT_VERSION=$VAULT_VERSION" >> $GITHUB_ENV
        echo "K3S_VERSION=$K3S_VERSION" >> $GITHUB_ENV

        # Install k3d for E2E tests
        echo "üê≥ Installing k3d..."
        curl -s https://raw.githubusercontent.com/k3d-io/k3d/main/install.sh | bash

        echo "‚úÖ E2E test versions:"
        echo "  Vault: $VAULT_VERSION"
        echo "  K3s: $K3S_VERSION"

    - name: Determine test packages and tags
      id: config
      shell: bash
      run: |
        echo "üîç Configuring E2E tests..."

        PACKAGES="./test/e2e/..."
        BASE_TAGS="e2e"

        # Add custom tags if provided
        if [[ -n "${{ inputs.test-tags }}" ]]; then
          TAGS="$BASE_TAGS,${{ inputs.test-tags }}"
        else
          TAGS="$BASE_TAGS"
        fi

        echo "packages=$PACKAGES" >> $GITHUB_OUTPUT
        echo "tags=$TAGS" >> $GITHUB_OUTPUT

        echo "‚úÖ E2E test configuration:"
        echo "  Packages: $PACKAGES"
        echo "  Tags: $TAGS"
        echo "  Working Dir: root (merged module structure)"

    - name: Setup E2E test cluster
      shell: bash
      run: |
        echo "üöÄ Setting up E2E test cluster..."

        # Create k3d cluster for E2E tests
        k3d cluster create e2e-test \
          --k3s-arg "--disable=traefik@server:*" \
          --wait --timeout 300s

        # Verify cluster is ready
        kubectl cluster-info
        kubectl get nodes

        echo "‚úÖ E2E test cluster ready"

    - name: Check for pre-built operator image
      id: check-image
      shell: bash
      run: |
        echo "üîç Checking for pre-built operator image..."

        # Look for existing image tags from CI build
        if [[ -n "${OPERATOR_IMAGE_TAG:-}" ]]; then
          echo "Found operator image tag from CI: $OPERATOR_IMAGE_TAG"
          echo "image-tag=$OPERATOR_IMAGE_TAG" >> $GITHUB_OUTPUT
          echo "use-prebuilt=true" >> $GITHUB_OUTPUT
        elif [[ -n "${OPERATOR_IMAGE_TAGS:-}" ]]; then
          # Extract first tag from newline-separated list
          FIRST_TAG=$(echo "$OPERATOR_IMAGE_TAGS" | head -n1)
          echo "Found operator image tags from CI, using first: $FIRST_TAG"

          # Pull the image to ensure it's available locally
          echo "üîÑ Pulling operator image for E2E tests..."
          if docker pull "$FIRST_TAG"; then
            echo "‚úÖ Successfully pulled $FIRST_TAG"
            echo "image-tag=$FIRST_TAG" >> $GITHUB_OUTPUT
            echo "use-prebuilt=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è Failed to pull $FIRST_TAG, will build from scratch"
            echo "use-prebuilt=false" >> $GITHUB_OUTPUT
          fi
        elif docker images --format "table {{.Repository}}:{{.Tag}}" | grep -E "ghcr.io/.*vault-unsealer:" | head -1; then
          EXISTING_TAG=$(docker images --format "{{.Repository}}:{{.Tag}}" | grep -E "ghcr.io/.*vault-unsealer:" | head -1)
          echo "Found existing operator image: $EXISTING_TAG"
          echo "image-tag=$EXISTING_TAG" >> $GITHUB_OUTPUT
          echo "use-prebuilt=true" >> $GITHUB_OUTPUT
        else
          echo "No pre-built operator image found, will build during test"
          echo "use-prebuilt=false" >> $GITHUB_OUTPUT
        fi

    - name: Run E2E tests
      id: run-tests
      shell: bash
      run: |
        echo "üåê Running E2E tests using make..."

        # Set environment variables for make command
        export TEST_TIMEOUT="${{ inputs.timeout }}"
        export PARALLELISM="${{ inputs.parallel }}"
        export VERBOSE="true"
        export CI="true"
        export VAULT_VERSION="${{ env.VAULT_VERSION }}"
        export K3S_VERSION="${{ env.K3S_VERSION }}"

        # Set pre-built image tag if available
        if [[ "${{ steps.check-image.outputs.use-prebuilt }}" == "true" ]]; then
          export OPERATOR_IMAGE_TAG="${{ steps.check-image.outputs.image-tag }}"
          echo "üöÄ Using pre-built operator image: $OPERATOR_IMAGE_TAG"
        else
          echo "üèóÔ∏è Will build operator image during test"
        fi

        # Run tests using make command for consistency
        if make test-e2e 2>&1 | tee "reports/e2e-test-output.log"; then
          echo "result=success" >> $GITHUB_OUTPUT
          echo "‚úÖ E2E tests completed successfully"
        else
          echo "result=failure" >> $GITHUB_OUTPUT
          echo "‚ùå E2E tests failed"
          exit 1
        fi

    - name: Generate test summary
      id: summary
      if: always()
      shell: bash
      run: |
        echo "üìä Generating E2E test summary..."

        # Parse test results
        TOTAL_TESTS=$(grep -c "^=== RUN" reports/e2e-test-output.log 2>/dev/null || echo "0")
        PASSED_TESTS=$(grep -c "--- PASS:" reports/e2e-test-output.log 2>/dev/null || echo "0")
        FAILED_TESTS=$(grep -c "--- FAIL:" reports/e2e-test-output.log 2>/dev/null || echo "0")
        SKIPPED_TESTS=$(grep -c "--- SKIP:" reports/e2e-test-output.log 2>/dev/null || echo "0")

        # Generate summary
        SUMMARY="## üåê E2E Test Results\\n\\n"
        SUMMARY="${SUMMARY}| Metric | Count |\\n"
        SUMMARY="${SUMMARY}|--------|-------|\\n"
        SUMMARY="${SUMMARY}| Total | $TOTAL_TESTS |\\n"
        SUMMARY="${SUMMARY}| Passed | $PASSED_TESTS |\\n"
        SUMMARY="${SUMMARY}| Failed | $FAILED_TESTS |\\n"
        SUMMARY="${SUMMARY}| Skipped | $SKIPPED_TESTS |\\n"

        echo "report<<EOF" >> $GITHUB_OUTPUT
        echo -e "$SUMMARY" >> $GITHUB_OUTPUT
        echo "EOF" >> $GITHUB_OUTPUT

        # Add to step summary
        echo -e "$SUMMARY" >> $GITHUB_STEP_SUMMARY

    - name: Process coverage
      id: coverage
      if: inputs.coverage == 'true' && always()
      shell: bash
      run: |
        if [[ -f "coverage/e2e-coverage.out" ]]; then
          echo "üìà Processing E2E coverage data..."

          # Generate coverage report
          go tool cover -html=coverage/e2e-coverage.out -o coverage/e2e-coverage.html
          go tool cover -func=coverage/e2e-coverage.out > coverage/e2e-coverage.txt

          # Extract coverage percentage
          COVERAGE=$(go tool cover -func=coverage/e2e-coverage.out | grep "total:" | awk '{print $3}' | sed 's/%//')
          echo "percentage=$COVERAGE" >> $GITHUB_OUTPUT

          echo "‚úÖ E2E Coverage: $COVERAGE%"

          # Add coverage to summary
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### üìä E2E Coverage: $COVERAGE%" >> $GITHUB_STEP_SUMMARY
        else
          echo "‚ö†Ô∏è No E2E coverage data found"
          echo "percentage=0" >> $GITHUB_OUTPUT
        fi

    - name: Collect cluster logs
      if: always()
      shell: bash
      run: |
        echo "üìã Collecting cluster logs for debugging..."

        # Get cluster state
        kubectl get all --all-namespaces > artifacts/cluster-state.log 2>/dev/null || true
        kubectl get events --all-namespaces --sort-by='.lastTimestamp' > artifacts/cluster-events.log 2>/dev/null || true
        kubectl top pods --all-namespaces > artifacts/cluster-resources.log 2>/dev/null || true

        # Get operator logs if deployed
        kubectl logs -l app=vault-unsealer --all-namespaces > artifacts/operator-logs.log 2>/dev/null || true

        echo "‚úÖ Cluster logs collected"

    - name: Upload test artifacts
      if: always()
      uses: actions/upload-artifact@v4
      with:
        name: e2e-test-results-${{ github.run_number }}
        path: |
          coverage/
          reports/
          artifacts/
          *.log
        retention-days: 14

    - name: Clean up test environment
      if: always()
      shell: bash
      run: |
        echo "üßπ Cleaning up E2E test environment..."

        # Clean up k3d cluster
        k3d cluster delete e2e-test 2>/dev/null || true

        # Clean up any remaining containers
        docker system prune -f --volumes --filter "label=org.testcontainers.sessionId" 2>/dev/null || true

        echo "‚úÖ E2E test environment cleaned up"

    - name: Set test result
      id: test-result
      if: always()
      shell: bash
      run: |
        if [[ "${{ steps.run-tests.outputs.result }}" == "success" ]]; then
          echo "result=success" >> $GITHUB_OUTPUT
        else
          echo "result=failure" >> $GITHUB_OUTPUT
        fi
